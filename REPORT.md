# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Медведев Е.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Основное отличие списков в Прологе заключается в том, что они используются по-другому в языке запросов. Вместо итерации и последовательного прохода по элементам списка запросы формулируются с помощью рекурсивных правил. Вместо реализации как отдельной структуры данных, списки в Прологе базируются на понятии отношения, которое реализуется с помощью предикатов. Список задается как цепочка отношений между элементами

## Задание 1.1: Предикат обработки списка

`find_index(X,Y,Z)` - Нахождение номера первого вхождения элемента с заданным значением

Примеры использования:
```prolog
?- find_index(2, [1, 2, 3, 4, 5], Index).
Index = 1

?- find_index(5, [1, 2, 3, 4, 5], Index).
Index = 4

?- find_index(10, [1, 2, 3, 4, 5], Index).
Index = -1

?- find_index(a, [a, b, c, a, d, e], Index).
Index = 0


```

Реализация :
```prolog
find_index(_, [], -1).
find_index(X, [X|_], 0).
find_index(X, [_|T], Index) :- 
    find_index(X, T, Index1), 
    Index is Index1 + 1.


```

Код, который находит индекс первого вхождения элемента X в списке. Он работает следующим образом:

Первое правило find_index(_, [], -1) указывает, что если список пуст, то индекс равен -1.
 
Второе правило find_index(X, [X|_], 0) указывает, что если элемент X совпадает с головой списка, то индекс равен 0.
 
Третье правило find_index(X, [_|T], Index) :- find_index(X, T, Index1), Index is Index1 + 1. рекурсивно вызывает find_index для остатка списка T, чтобы найти индекс элемента X в остатке списка. Затем индекс Index1 увеличивается на 1, чтобы получить индекс в исходном списке.


`find_index(X,Y,Z)` - Нахождение номера первого вхождения элемента с заданным значением (предикат на основе стандартных предикатов)

Примеры использования:
```prolog
?- find_index(2, [1, 2, 3, 4, 5], Index).
Index = 1

?- find_index(5, [1, 2, 3, 4, 5], Index).
Index = 4

?- find_index(10, [1, 2, 3, 4, 5], Index).
Index = -1

?- find_index(a, [a, b, c, a, d, e], Index).
Index = 0



```

Реализация :
```prolog
find_index(_, [], -1).
find_index(Element, List, Index) :-
    length(Prefix, Index),
    append(Prefix, [Element|_], List).



```

Этот предикат использует стандартные предикаты length, append и member для нахождения номера первого вхождения элемента в списке.

Первое правило find_index(_, [], -1) указывает, что если список пуст, то индекс равен -1. 
Второе правило find_index(Element, List, Index) :- length(Prefix, Index), append(Prefix, [Element|_], List). использует предикаты length и append для разделения списка на префикс Prefix длиной Index и оставшуюся часть списка, начинающуюся с элемента Element. Если такое разделение возможно, то элемент найден и его индекс равен Index.


## Задание 1.2: Предикат обработки числового списка

`sum_list(X,Y)` - Вычисляет сумму всех элементов в списке.

Примеры использования:
```prolog
?- sum_list([1, 2, 3, 4, 5], Sum).
Sum = 15

?- sum_list([10, 20, 30, 40, 50], Sum).
Sum = 150

?- sum_list([], Sum).
Sum = 0

?- sum_list([5], Sum).
Sum = 5



```

Реализация:
```prolog
sum_list([], 0).
sum_list([X|T], Sum) :- 
    sum_list(T, Sum1), 
    Sum is X + Sum1.



```

Он работает следующим образом:

Первое правило sum_list([], 0) указывает, что сумма пустого списка равна 0. 

Второе правило sum_list([X|T], Sum) :- sum_list(T, Sum1), Sum is X + Sum1. рекурсивно вызывает sum_list для остатка списка T, чтобы вычислить сумму оставшихся элементов. Затем сумма Sum1 увеличивается на значение головы списка X, чтобы получить общую сумму.


`sum_elements(X,Y)` - Вычисляет сумму всех элементов в списке (предикат на основе стандартных предикатов).

Примеры использования:
```prolog
?- sum_elements([1, 2, 3], Sum).
Sum = 6

?- sum_elements([4, 5, 6, 7], Sum).
Sum = 22

?- sum_elements([], Sum).
Sum = 0

?- sum_elements([10], Sum).
Sum = 10




```

Реализация:
```prolog
sum_elements([], 0).
sum_elements(List, Sum) :-
    sublist(Sublist, List),
    permute(Sublist, Permutation),
    remove(_, Permutation, UniquePermutation),
    member(Element, UniquePermutation),
    sum_list(Element, Sum).




```

Первое правило sum_elements([], 0) указывает, что сумма элементов пустого списка равна 0. 
Второе правило sum_elements(List, Sum) :- sublist(Sublist, List), permute(Sublist, Permutation), remove(_, Permutation, UniquePermutation), member(Element, UniquePermutation), sum_list(Element, Sum). использует предикаты sublist, permute, remove, member и sum_list для нахождения всех подсписков Sublist и их перестановок Permutation в исходном списке List.
Затем удаляются повторяющиеся перестановки с помощью remove и выбирается элемент Element из уникальных перестановок. Наконец, суммируются элементы выбранного подсписка с помощью предиката sum_list, чтобы получить общую сумму.


## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




